<!DOCTYPE html>
<html lang="en-us" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='说来话长。'><title>多线程·并发编程</title>

<link rel='canonical' href='https://h2cone.github.io/2020/02/21/thread_concurrent/'>

<link rel="stylesheet" href="/scss/style.min.977b857f8a1925fed67b52046950e93feabd26d72412e38678ca62d2964c41c9.css"><meta property='og:title' content='多线程·并发编程'>
<meta property='og:description' content='说来话长。'>
<meta property='og:url' content='https://h2cone.github.io/2020/02/21/thread_concurrent/'>
<meta property='og:site_name' content='Huangh&#39;s blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='java' /><meta property='article:tag' content='concurrent' /><meta property='article:published_time' content='2020-02-21T17:47:30&#43;08:00'/><meta property='article:modified_time' content='2020-02-21T17:47:30&#43;08:00'/>
<meta name="twitter:title" content="多线程·并发编程">
<meta name="twitter:description" content="说来话长。">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Huangh&#39;s blog</a></h1>
            <h2 class="site-description">^^^^^^^^^^^^^^^^^</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/h2cone'
                        target="_blank"
                        title="GitHub"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com/0xwater'
                        target="_blank"
                        title="Twitter"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>Dark Mode</span>
                </li>
            
        </div>
    </ol>
</aside>
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/2020/02/21/thread_concurrent/">多线程·并发编程</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            说来话长。
        </h3>
        
    </div>

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Feb 21, 2020</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    16 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>
</header>

    <section class="article-content">
    
    
    <h2 id="进程与线程">进程与线程</h2>
<p>现代的计算机系统提供了许多漂亮的<strong>抽象</strong>，如下图所示：</p>
<p><img src="/img/csapp/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%8a%bd%e8%b1%a1.png"
	
	
	
	loading="lazy"
	
		alt="计算机系统的抽象"
	
	
></p>
<p>其中，进程是对处理器、主存和 I/O 设备的抽象，换言之，进程是操作系统对一个正在运行的程序的一种抽象。操作系统上可以“同时”运行多个进程，已经对一边听歌一边写代码和接收消息的流畅不足为奇，之所以用双引号，因为这可能是一种假象。</p>
<p>大多数计算机系统中，需要运行的进程数是多于可以运行它们的 CPU 个数的，那么所谓的”同时“运行，很有可能是模拟并发的假象；也就是说一个进程的指令和另一个进程的指令是被 CPU 交错执行的，而且 CPU 在进程间切换足够快，进程“暂停”和“恢复”的间隔也足够短，每个进程看上去像是连续运行。除非有多个 CPU 或多处理器的计算机系统，才能支持多进程并行，即处理器同时执行多个程序的指令。</p>
<p>一个进程用完了操作系统分配给它的时间片，操作系统决定把控制权转移给新的进程，就会进行<strong>上下文切换（context switch）</strong>，即保存当前进程的状态，恢复目标进程的状态，交接控制权。这种状态被称为上下文（context），比如程序计数器和寄存器的当前值以及主存的内容。</p>
<p>一个进程可以存在多个控制流（control flow），它们被称为线程。如来自维基百科线程词条的插图所示：</p>
<p><img src="/img/thread_concurrent/Multithreaded_process.svg"
	
	
	
	loading="lazy"
	
		alt="Multithreaded_process"
	
	
></p>
<p>因为只有单处理器，所以这个进程的两个线程轮番运行在进程的上下文中（模拟并发）。操作系统不仅调度进程，教科书常说，线程是操作系统调度的最小单位。大多数计算机系统中，需要运行的线程数大于可以运行它们的 CPU 核数，从单线程进程推广到多线程进程的线程，一个线程时间到了，上下文切换，它被“暂停”了，轮到了另一个线程运行，稍后轮到它时又“恢复”了。</p>
<p>多线程程序十分普遍。电脑和手机应用程序在用户界面渲染动画，同时在后台执行计算和网络请求。一个 Web 服务器一次处理数千个客户端的请求。多线程下载、多线程爬虫、多线程遍历文件树&hellip;&hellip;多线程成为越来越重要的模型，因为多线程程序有不少优点。</p>
<p>多线程之间比多进程之间更容易共享数据和通信。同一个进程的多个线程共享进程的资源，比如进程的<strong>虚拟地址空间</strong>中的程序代码和程序处理的数据以及文件，对于同一进程的线程们来说，可执行代码只有一套，它们可以访问存储在堆 (Heap) 中的共享变量或全局变量，但是，栈（Stack）、包括程序计数器（Program Counter）在内的寄存器（Register）副本、线程本地存储（Thread Local Storage）都是线程私有的（如果有的话）。不仅如此，线程之间可以通过共享的代码、数据、文件进行通信，绝大部分情况下比进程间的通信更高效。</p>
<p><img src="/img/thread_concurrent/4_01_ThreadDiagram.jpg"
	
	
	
	loading="lazy"
	
		alt="4_01_ThreadDiagram"
	
	
></p>
<p>多线程执行任务更多或更快。如果主线程阻塞在耗时任务，整个程序可能会卡顿或长时间无响应，解决办法之一便是新建一个工作线程专门执行这个耗时任务，而主线程则继续执行其它任务。例如，前面提到的手机 APP（特别是 Android APP），UI 线程被阻塞后很有可能无法正常人机交互了，用户体验极差。更进一步，单进程的多线程之间的协作有可能提高 client-server 系统的性能，譬如异步调用缩短了请求响应时间（也许总延迟几乎没变）。最重要的是，虽然一个传统的 CPU 只能交错执行一个进程的多个线程，但随着多核处理器和超线程（hyperthreading）的普及，面对多任务或大任务的执行，多线程程序的性能上限具有更高的天花板，因为减少了执行多个任务需要模拟并发的开销，还因为处理器可以并行运行多个线程。</p>
<h2 id="并发与并行">并发与并行</h2>
<p>并发（Concurrency）和并行（Parallelism）这两个术语经常混淆，语义应当结合语境。</p>
<p><img src="/img/thread_concurrent/%e4%b8%b2%e8%a1%8c%e5%92%8c%e5%b9%b6%e8%a1%8c%e4%bb%a5%e5%8f%8a%e5%b9%b6%e5%8f%91.png"
	
	
	
	loading="lazy"
	
		alt="串行和并行以及并发"
	
	
></p>
<p>如上图所示，假设有两个任务和两个线程，每个任务只能由一线程执行且用时分别是 t1 和 t2（t1 &lt; t2），且线程都是同时启动，那么各个方式总执行时间可能如下表所示：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">方式</th>
<th style="text-align:center">总执行时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">串行</td>
<td style="text-align:center">t1 + t2</td>
</tr>
<tr>
<td style="text-align:center">并行</td>
<td style="text-align:center">t2</td>
</tr>
<tr>
<td style="text-align:center">单处理器并发</td>
<td style="text-align:center">t1 + t2 + 上下文切换总时间</td>
</tr>
</tbody>
</table></div>
<p>由此可见，如果上下文切换的耗时可以忽略不计，单处理器并发不仅执行总时间近似于串行执行总时间，还有一个优点是同时执行两个任务的假象。并行的方式非常快，但也取决于最耗时的任务。</p>
<p>在多处理器计算机系统中，多线程交错执行或并行执行都有可能出现，下文将”交错或并行“统称为”并发“。</p>
<h2 id="java-多线程">Java 多线程</h2>
<h3 id="java-进程">Java 进程</h3>
<p>任何 Java 应用程序都跑在操作系统之上，操作系统作为硬件和应用程序的<strong>中间层</strong>，隐藏了下层具体实现的复杂性，并给上层提供了简单或统一的接口。</p>
<p><img src="/img/csapp/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%88%86%e5%b1%82.png"
	
	
	
	loading="lazy"
	
		alt="计算机系统的分层"
	
	
></p>
<p>正在运行的 Java 程序就是 Java 虚拟机（JVM），而虚拟机是对整个操作系统的抽象，但对操作系统来说 JVM 仍然是进程。下面这张来自 <a class="link" href="http://blog.jamesdbloom.com/JVMInternals.html"  target="_blank" rel="noopener"
    >JVM Internals</a> 的图展示了 Java SE 7 虚拟机运行时的数据区域（Run-Time Data Areas）。图中的堆和栈类似于 Linux/Unix 操作系统进程的虚拟地址空间中的堆和栈，值得注意的是 Java 8 用<strong>元空间（Metaspace）代替了永久代（PermGen）</strong>。JVM 运行时的数据区域可分成两大类，一是 Java 线程共享区域，包括堆和方法区；二是 Java 线程私有区域，包括栈，详情请见 <a class="link" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5"  target="_blank" rel="noopener"
    >The Java Virtual Machine Specification, Java SE 8 Edition # 2.5. Run-Time Data Areas</a>。</p>
<p><img src="/img/jvm/JVM_Internal_Architecture.png"
	
	
	
	loading="lazy"
	
		alt="JVM_Internal_Architecture"
	
	
></p>
<p>Java SE 最常用的虚拟机是 Oracle/Sun 研发的 Java HotSpot VM。HotSpot 基本的线程模型是 Java 线程与原生线程（native thread）之间 1:1 的映射。线程通常在操作系统层实现或在应用程序层实现，前者的线程称为内核线程，后者的线程可能称为用户线程。内核（kernel）是操作系统代码常驻主存的部分，而所谓用户，就是应用程序和应用程序开发者。</p>
<p>前文提到，充分利用多处理器能使多线程程序运行得更快。在操作系统层，消费多处理器的是内核线程，操作系统负责调度所有内核线程（原生线程）并派遣到任何可用的 CPU，因为 Java 线程与内核线程（原生线程）是一对一映射，所以充分利用多处理器能增强 Java 程序的性能。</p>
<h3 id="启动线程">启动线程</h3>
<p>对于 HotSpot VM 来说，Java 线程是 <code>java.lang.Thread</code> 的实例。Java 用户可以使用类继承 <code>java.lang.Thread</code> 来新建和启动 Java 线程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloThread</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Hello from a thread&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">new</span> <span class="n">HelloThread</span><span class="o">().</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>或者使用类实现 <code>java.lang.Runnable</code> 来新建和启动线程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloRunnable</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Hello from a thread&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">HelloRunnable</span><span class="o">()).</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Java 8 以上的用户也许更倾向于使用匿名内部类实现 <code>java.lang.Runnable</code> 或 Lambda 表达式简化以上代码，但都是通过调用 <code>java.lang.Thread#start</code> 方法来启动新线程，对应的原生线程（内核线程）在启动 Java 线程时创建，并在终止时回收。其中，<code>run</code> 方法是 Java 线程启动后执行的语句组，即人类要求它执行的任务，而 <code>main</code> 方法的语句是 Java 用户直接或间接通过命令行启动 JVM 后执行。</p>
<p><img src="/img/thread_concurrent/main-thread-in-java.jpeg"
	
	
	
	loading="lazy"
	
		alt="main-thread-in-java"
	
	
></p>
<p>如上图所示，即使运行一个简单的 &ldquo;Hello World&rdquo; 程序，也可能在 JVM 或操作系统创建十几个或更多线程。例如执行 <code>main</code> 方法的语句需要的主线程，主线程能启动子线程并执行后续语句，子线程也能启动其子线程并执行后续语句，而且还有其它由 HotSpot 为了内部目的而创建的线程，如 VM thread、Periodic task thread、GC threads、Compiler threads、Signal dispatcher thread。</p>
<p><a class="link" href="https://juejin.cn/post/6844903893294383117"  target="_blank" rel="noopener"
    >主线程终止，其它线程还会运行吗？</a></p>
<h3 id="threadlocal">ThreadLocal</h3>
<p>前面提到了线程有若干的私有区域，其中之一能在 <code>java.lang.Thread</code> 中找到数据结构。<code>Thread</code> 维护了一个类型为 <code>java.lang.ThreadLocal.ThreadLocalMap</code> 的字段，<code>ThreadLocalMap</code> 是一个定制化的 HashMap，key 的类型是 <code>ThreadLocal</code>，value 指代线程本地变量的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TransactionId</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">ThreadLocal</span><span class="o">.</span><span class="na">withInitial</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">0L</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Long</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">tid</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">Long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">tid</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上所示，类型为 <code>ThreadLocal</code> 的字段初始化后，每个访问该字段（通过 get 或 set 方法）的线程访问的是各自 <code>ThreadLocalMap</code> 实例存储的 key/value，其中类型是 <code>ThreadLocal</code> 的 key 相等，但 value 不一定相等。</p>
<h3 id="线程状态">线程状态</h3>
<p>下面这个来自 <a class="link" href="https://www.uml-diagrams.org/examples/java-6-thread-state-machine-diagram-example.html"  target="_blank" rel="noopener"
    >Java 6 Thread States and Life Cycle</a> 的状态机，很好地描述了 Java 线程状态和生命周期。</p>
<p><img src="/img/thread_concurrent/state-machine-example-java-6-thread-states.png"
	
	
	
	loading="lazy"
	
		alt="state-machine-example-java-6-thread-states"
	
	
></p>
<p>翻阅 JDK 8 的 <code>java.lang.Thread.State</code> 可以确定，在给定的时间点，一个 Java 线程只能处于以下状态之一：</p>
<ul>
<li>
<p>New。尚未启动的线程处于此状态。</p>
</li>
<li>
<p>Runnable。Java 虚拟机中正在执行的线程处于此状态。</p>
</li>
<li>
<p>Blocked。等待获得监视器锁（monitor lock）而被阻塞的线程处于此状态。</p>
</li>
<li>
<p>Waitting。无限期地等待另一个线程执行特定操作的线程处于此状态。</p>
</li>
<li>
<p>Timed Waiting。有限期地等待另一个线程执行特定操作的线程处于此状态。</p>
</li>
<li>
<p>Terminated。终止的线程处于此状态。</p>
</li>
</ul>
<p>如状态机所示，当线程执行不同操作时，线程状态发生转换，这些操作对应于 JDK 已提供的方法。注意上图的 o 表示 Object，t 表示 Thread。</p>
<h3 id="通知">通知</h3>
<h4 id="waitnotify">wait/notify</h4>
<p>一个线程处于等待状态时，可以被另外一个线程通知，转为可运行状态。比如，一个线程用一个对象（的引用）调用 <code>Object#wait()</code>，另一个线程用同一个对象（的引用）调用 <code>Object#notify()</code> 或 <code>Object#notifyAll()</code>，前提是它们必须拥有该对象的内置锁；第一个线程调用 <code>Object#wait()</code> 时，它会释放该对象的内置锁并“暂停”，第二个线程获得该对象的内置锁成功之后，调用 <code>Object#notifyAll()</code> 通知所有曾经用同一个对象（的引用）调用了 <code>Object#wait()</code> 的线程有重要事情发生；在第二个线程释放了该对象的内置锁后的某个时刻，第一个线程重新获得了该对象的内置锁，并从 <code>Object#wait()</code> 返回而“恢复”。阻塞状态与内置锁或监视器锁息息相关，将在下文的&quot;锁和同步&quot;讨论。</p>
<p>详情请见 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html"  target="_blank" rel="noopener"
    >Object</a>。</p>
<h4 id="interrupt">interrupt</h4>
<p>另外，线程有一个中断状态（interrupt status）。所谓中断，即停止正在执行的操作，并执行其它操作。例如，主线程可使用子线程对象（的引用）调用 <code>java.lang.Thread#interrupt()</code> 中断子线程，子线程能够捕获 <code>java.lang.InterruptedException</code> 或调用 <code>java.lang.Thread#interrupted()</code> 接收到中断。</p>
<p>详情请见 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html"  target="_blank" rel="noopener"
    >Thread</a>。</p>
<h4 id="parkunpark">park/unpark</h4>
<p>类比申请许可和提供许可。相比于 wait/notify，park/unpark 对调用顺序没有要求。线程调用 <code>LockSupport#park()</code> 时“暂停”，线程调用 <code>LockSupport#unpark(Thread)</code> 时取消给定线程的“暂停”，如果给定线程已“暂停”，则给定线程从 <code>LockSupport#park()</code> 返回而“恢复”，如果给定线程没有“暂停”，那么将来给定线程第一次调用 <code>LockSupport#park()</code> 时立即返回。</p>
<p>详情请见 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html"  target="_blank" rel="noopener"
    >LockSupport</a>。</p>
<h4 id="spurious-wakeup">spurious wakeup</h4>
<p>中断和虚假唤醒可能发生，官方建议在循环体内使用 wait 和 park，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">synchronized</span> <span class="o">(</span><span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="o">(&lt;</span><span class="n">condition</span> <span class="n">does</span> <span class="n">not</span> <span class="n">hold</span><span class="o">&gt;)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">obj</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span> <span class="c1">// Perform action appropriate to condition
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>或者：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">while</span> <span class="o">(</span><span class="n">waiters</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">!=</span> <span class="n">current</span> <span class="o">||</span> <span class="o">!</span><span class="n">locked</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ignore interrupts while waiting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wasInterrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="线程池">线程池</h3>
<p>使用 <code>Thread.start(...)</code> 启动线程足以执行基本的任务，但是对于复杂任务，例如有返回值的任务和定时任务等，其 API 过于低级。大规模的应用程序中，将线程的创建和管理从应用程序其余部分分开是很有意义的，理由之一是分离关注点能够减弱复杂性。封装了线程的创建和管理的对象们称为 Executors。JDK 的 <code>java.util.concurrent</code> 包定义了三代 <code>Executor</code> 接口：</p>
<ul>
<li>
<p><a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html"  target="_blank" rel="noopener"
    >Executor</a></p>
</li>
<li>
<p><a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html"  target="_blank" rel="noopener"
    >ExecutorService</a></p>
</li>
<li>
<p><a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html"  target="_blank" rel="noopener"
    >ScheduledExecutorService</a></p>
</li>
</ul>
<p>如果 r 是 <code>Runnable</code> 对象，而 e 是 <code>Executor</code> 对象，则可以使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">e</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>代替</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">r</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/img/thread_concurrent/Executor-execution-logic.jpg"
	
	
	
	loading="lazy"
	
		alt="Executor-execution-logic"
	
	
></p>
<p><code>Executor</code> 接口大部分实现都使用<strong>线程池（Thread Pool）</strong>，这就是理由之二。例如，一个一般的服务器端程序服务着多个客户端，如果每个客户端的请求都通过新建一个线程来处理，即线程数随着请求数增加而增加，虽然新建线程比新建进程便宜，但是当活跃的线程数太多时，不仅占用大量的内存，容易导致内存溢出，而且操作系统内核需要花费大量的时间在线程调度上（上下文切换），大量的线程“暂停”较长时间，还因频繁新建和终结执行短时任务的线程而引起的延迟，大量客户端长时间得不到响应。</p>
<p>对于 Java Hotspot VM 来说，大量线程的另一个问题是巨大的根集合（root set），因此 GC 停顿阶段（stop-the-world pause）更长。</p>
<p>线程池由数量可控的<strong>工作线程（worker thread）</strong> 组成，每个工作线程的生命都被延长，以便用于执行多个任务，既减少了上下文切换引起的延迟，也减少了频繁新建和终结执行短暂任务的线程而引起的延迟。线程池的新建通常是预处理，即服务器端程序提供服务之前已准备好线程池，避免了临时新建大量线程的开销。</p>
<p>线程池有一种类型是固定线程池（fixed thread pool），如果某个线程仍在使用中而被某种方式终止，那么就会有新的线程代替它。任务通过队列提交到池中，任务队列可以容纳超过线程池中线程数量的的任务。这样设计的好处是优雅降级（degrade gracefully）和削峰。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="n">ExecutorService</span> <span class="nf">newFixedThreadPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">nThreads</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">ThreadPoolExecutor</span><span class="o">(</span><span class="n">nThreads</span><span class="o">,</span> <span class="n">nThreads</span><span class="o">,</span> <span class="n">0L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span> <span class="k">new</span> <span class="n">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;());</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面是 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html"  target="_blank" rel="noopener"
    >Executors</a> 的新建固定线程池的简单方法。注意当中的参数类型，<code>LinkedBlockingQueue</code>，它是 <code>BlockingQueue</code> 的基于链表的实现类，作为阻塞队列，它有一个特性，当队列为空时，线程从队列拉取元素会被阻塞或被迫等待。仔细翻阅源码，可以知道线程池的预先新建和工作线程的生命延长是通过阻塞工作线程或使之有限期等待来实现。除此之外，任务队列的的任务抽象为 <code>Runable</code>。</p>
<p>新建线程池返回一个 <code>ExecutorService</code> 实例，利用它来提交任务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Future</span><span class="o">&lt;?&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">});</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>submit</code> 方法可传递 <code>Runable</code> 引用或 <code>Callable</code> 引用，两者的关系如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Runnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FutureTask</span><span class="o">&lt;&gt;(</span><span class="n">callable</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html"  target="_blank" rel="noopener"
    >Future</a> <del>表示异步结果</del>。主线程调用 <code>Future#get</code> 方法时被迫等待，直到子线程完成相应的任务后，主线程从 <code>Future#get</code> 方法返回得到结果并执行后续语句。</p>
<p><a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html"  target="_blank" rel="noopener"
    >CompletableFuture</a> 实现了 <code>Future</code>，并且支持设置回调方法。主线程无需等待工作线程完成相应的任务，当工作线程完成相应的任务后，回调方法会被调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">},</span> <span class="n">threadPoolExecutor</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">future</span><span class="o">.</span><span class="na">thenCompose</span><span class="o">(</span><span class="n">obj</span> <span class="o">-&gt;</span> <span class="n">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// do other things
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}),</span> <span class="n">threadPoolExecutor</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">future</span><span class="o">.</span><span class="na">whenComplete</span><span class="o">((</span><span class="n">obj</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// callback
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">},</span> <span class="n">threadPoolExecutor</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>设想一下多线程并发处理事件，要求主线程等待所有任务完成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;&gt;</span> <span class="n">futures</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">events</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="n">Event</span> <span class="n">event</span> <span class="o">:</span> <span class="n">events</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// handle event
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">event</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">},</span> <span class="n">threadPoolExecutor</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">futures</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">future</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">allFuture</span> <span class="o">=</span> <span class="n">CompletableFuture</span><span class="o">.</span><span class="na">allOf</span><span class="o">(</span><span class="n">futures</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="n">CompletableFuture</span><span class="o">[</span><span class="n">0</span><span class="o">]));</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">allFuture</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 <code>Executors</code> 新建线程池，需要注意的是，可能会因为任务队列堆积过多任务从而导致内存溢出，因为 <code>LinkedBlockingQueue</code> 可自动扩容，最大值为 <code>Integer.MAX_VALUE</code>。<strong>建议合理设置线程池的各个参数</strong>，例如使用构造器新建线程池：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">new</span> <span class="n">ThreadPoolExecutor</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maximumPoolSize</span><span class="o">,</span> <span class="kt">long</span> <span class="n">keepAliveTime</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">,</span> <span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span> <span class="n">workQueue</span><span class="o">,</span> <span class="n">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">,</span> <span class="n">RejectedExecutionHandler</span> <span class="n">handler</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>提交任务后，可能的情况如下所示：</p>
<p><img src="/img/thread_concurrent/ThreadPoolExecutor.png"
	
	
	
	loading="lazy"
	
		alt="ThreadPoolExecutor"
	
	
></p>
<p>详情见 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html"  target="_blank" rel="noopener"
    >ThreadPoolExecutor</a> 和 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html"  target="_blank" rel="noopener"
    >ScheduledThreadPoolExecutor</a>。</p>
<h3 id="forkjoin">Fork/Join</h3>
<p>Fork/Join 框架是 <code>ExecutorService</code> 接口的实现，它是为了可以分而治之的任务或工作而设计的，目标是使用所有可用的处理器来提高应用程序的性能。Fork/Join 框架分配任务给线程池中的工作线程，但是与一般的线程池不一样，它使用<a class="link" href="https://en.wikipedia.org/wiki/Work_stealing"  target="_blank" rel="noopener"
    >工作窃取</a>算法，空闲的工作线程可以窃取繁忙的工作线程的任务来执行，这个线程池称为 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html"  target="_blank" rel="noopener"
    >ForkJoinPool</a>。</p>
<p>工作线程很有可能会被 BOSS 命令按以下套路工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if 我的工作量足够小
</span></span><span class="line"><span class="cl">    直接做工作
</span></span><span class="line"><span class="cl">else
</span></span><span class="line"><span class="cl">    将我的工作分为两个片段
</span></span><span class="line"><span class="cl">    调用两个片段并等待结果
</span></span></code></pre></td></tr></table>
</div>
</div><p>分而治之，通常把一个足够大的工作任务递归分解为两个或多个相同或相似的子任务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BigTask</span> <span class="kd">extends</span> <span class="n">RecursiveAction</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">long</span><span class="o">[]</span> <span class="n">src</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="n">len</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">BigTask</span><span class="o">(</span><span class="kt">long</span><span class="o">[]</span> <span class="n">src</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">src</span> <span class="o">=</span> <span class="n">src</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">len</span> <span class="o">=</span> <span class="n">len</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">1000</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 直接操作 src
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">split</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">invokeAll</span><span class="o">(</span><span class="k">new</span> <span class="n">BigTask</span><span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">split</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">                    <span class="k">new</span> <span class="n">BigTask</span><span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">split</span><span class="o">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">split</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>假设这个大任务（BigTask）是对一个很长的数组（src）进行某些操作，例如排序、map、reduce、过滤、分组等。其中 BigTask 继承了 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveAction.html"  target="_blank" rel="noopener"
    >RecursiveAction</a>，重写了 <code>compute</code> 方法。然后，新建一个线程池，命令工作线程执行大任务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">long</span><span class="o">[]</span> <span class="n">src</span> <span class="o">=</span> <span class="o">...;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BigTask</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BigTask</span><span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">src</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ForkJoinPool</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForkJoinPool</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">pool</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个工作线程调用了 <code>compute</code> 方法，先判断当前 src 的长度是否小于阈值（threshold），若是则认为这个任务足够小，单线程很快就能完成对 src 的操作，否者就认为这个任务足够大，需要分工，于是先把 src 分成两个片段，然后调用 <code>invokeAll</code> 方法，其它工作线程去执行这两个子任务，又调用了 <code>compute</code> 方法&hellip;&hellip;在多处理器计算机系统中，因为支持多线程并行，所以这类程序通常运行得很快。</p>
<p>如果需要返回值，则可以使用 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveTask.html"  target="_blank" rel="noopener"
    >RecursiveTask</a>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FibonacciTask</span> <span class="kd">extends</span> <span class="n">RecursiveTask</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">FibonacciTask</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="n">Integer</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">FibonacciTask</span> <span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FibonacciTask</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">f1</span><span class="o">.</span><span class="na">fork</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">FibonacciTask</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FibonacciTask</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">f2</span><span class="o">.</span><span class="na">compute</span><span class="o">()</span> <span class="o">+</span> <span class="n">f1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ExecutionException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ForkJoinPool</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForkJoinPool</span>
</span></span><span class="line"><span class="cl">                <span class="o">(</span><span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">                        <span class="n">ForkJoinPool</span><span class="o">.</span><span class="na">defaultForkJoinWorkerThreadFactory</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                        <span class="kc">null</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ForkJoinTask</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">task</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">FibonacciTask</span><span class="o">(</span><span class="n">10</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">Integer</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>先分解，后合并。</p>
<p><img src="/img/thread_concurrent/fork-join.png"
	
	
	
	loading="lazy"
	
		alt="fork-join"
	
	
></p>
<p>JDK 的 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html"  target="_blank" rel="noopener"
    >java.util.Arrays</a> 和 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html"  target="_blank" rel="noopener"
    >java.util.streams</a> 提供了许多操作聚合类型实例的并行化方法，这些方法通常基于 Fork/Join。</p>
<h3 id="非线程安全">非线程安全</h3>
<p>前面说到了多线程程序的优点，但它也有明显的缺点。因为多个线程并发执行，且多个线程共享同一份只读代码，当多个线程并发读写共享变量或全局变量时，可能出现线程干扰（thread interference）和内存一致性错误（memory consistency errors），从而无法保证程序功能正确，也称为线程不安全。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">long</span> <span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">count</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">value</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面是一个简单的计数器（Counter），其中有一个将计数器的值（count）增加 1 的方法（increment）。从人脑的角度，increment 方法可分解为三个步骤：</p>
<ol>
<li>读取 count 的值。</li>
<li>计算 count + 1。</li>
<li>把计算结果写回 count。</li>
</ol>
<p>从计算机处理器的角度：</p>
<ol>
<li>从主存复制 count 的值和 1 的值到两个寄存器，以覆盖寄存器原来的值。</li>
<li>把两个寄存器的值复制到 ALU，ALU 对这两个值做算术运算。</li>
<li>ALU 将运算结果存入一个寄存器，以覆盖该寄存器原来的值。</li>
</ol>
<p>假设两个线程读取了 count 的值为 0，两个线程都在计算 0 + 1，一个线程比另一个线程更快把计算结果写回 count，此时 count 的值为 1，较慢的线程把 1 写回了 count，最终 count 的值是错误的 1，而不是正确的 2。在转账场景下，相互覆盖或丢失修改是一个非常严重的错误，例如两个人同时对一个银行账户进行取款或存款，如果银行软件系统开发者仍然有<a class="link" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%83%AF%E6%80%A7"  target="_blank" rel="noopener"
    >线程惯性</a>，那么结果可能取多了金额或存少了金额。</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">线程 1</th>
<th style="text-align:center">线程 2</th>
<th style="text-align:center"> </th>
<th style="text-align:center">整数值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"> </td>
<td style="text-align:center"> </td>
<td style="text-align:center"> </td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">读取</td>
<td style="text-align:center"> </td>
<td style="text-align:center">&lt;-</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td style="text-align:center">读取</td>
<td style="text-align:center">&lt;-</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">增加</td>
<td style="text-align:center"> </td>
<td style="text-align:center"> </td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td style="text-align:center">增加</td>
<td style="text-align:center"> </td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">写回</td>
<td style="text-align:center"> </td>
<td style="text-align:center">-&gt;</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td style="text-align:center">写回</td>
<td style="text-align:center">-&gt;</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table></div>
<p>下面通过 <a class="link" href="https://github.com/junit-team"  target="_blank" rel="noopener"
    >Junit</a> 测试，来证实线程不安全的存在。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CounterTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">wait</span> <span class="o">=</span> <span class="n">3000</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">threads</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">times</span> <span class="o">=</span> <span class="n">1000000</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">excepted</span> <span class="o">=</span> <span class="n">threads</span> <span class="o">*</span> <span class="n">times</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testIncrement</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Counter</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Counter</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">startThreads</span><span class="o">(</span><span class="n">counter</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">times</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">counter</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;threadName: %s, counterValue: %s\n&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">counter</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="o">});</span>
</span></span><span class="line"><span class="cl">        <span class="n">Assert</span><span class="o">.</span><span class="na">assertNotEquals</span><span class="o">(</span><span class="n">excepted</span><span class="o">,</span> <span class="n">counter</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">startThreads</span><span class="o">(</span><span class="n">Counter</span> <span class="n">counter</span><span class="o">,</span> <span class="n">Runnable</span> <span class="n">runnable</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">runnable</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">CounterTest</span><span class="o">.</span><span class="na">wait</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;threadName: %s, exceptedCounterValue: %s, actualCounterValue: %s\n&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">excepted</span><span class="o">,</span> <span class="n">counter</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个临时测试线程调用了 testIncrement 方法，启动了 2 个子线程，为了避免其中一个线程已经停止了，而另外一线程启动中，模拟了一个耗时任务，两个线程都要重复调用 Counter 的 increment 方法 1000000 次。注意，临时测试线程跳出循环后，会睡眠 3000 毫秒，才继续往下执行，预期结果为 2000000（子线程数与递增次数的乘积）。此处省略本机信息，测试结果如下：</p>
<p><img src="/img/thread_concurrent/testIncrement.png"
	
	
	
	loading="lazy"
	
		alt="testIncrement"
	
	
></p>
<p>临时测试线程和两个子线程取得 count 的值都是错误的。根本原因是多线程并发访问共享变量或全局变量时，每个线程对该变量赋值前的值与它读取的值不一致，最终导致了程序错误。结合上面提到的 JVM 运行时的数据区域，可以推断出 Java 各种变量是否线程安全。</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">区域</th>
<th style="text-align:center">是否线程共享</th>
<th style="text-align:center">是否线程安全</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">实例字段（instance field）</td>
<td style="text-align:center">堆</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">静态字段（static field）</td>
<td style="text-align:center">堆</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">本地变量（local variable）</td>
<td style="text-align:center">栈</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table></div>
<h2 id="java-并发编程">Java 并发编程</h2>
<h3 id="锁">锁</h3>
<p>保证多线程并发访问共享资源的程序正确，有一个直观的解决方案——锁（Lock）。</p>
<p><img src="/img/thread_concurrent/lock.png"
	
	
	
	loading="lazy"
	
		alt="lock"
	
	
></p>
<ol>
<li>
<p>只有获得锁成功的线程才能进入临界区（critical section），访问共享资源。</p>
</li>
<li>
<p>访问共享资源完成后，即使过程发生异常，也一定要释放锁，退出临界区。</p>
</li>
</ol>
<p>软件层的锁通常需要硬件层支持才能有效实现。这种支持通常采取一种或多种<a class="link" href="%28https://en.wikipedia.org/wiki/Linearizability%29" >原子</a>指令的形式，如 <a class="link" href="https://en.wikipedia.org/wiki/Test-and-set"  target="_blank" rel="noopener"
    >test-and-set</a>、<a class="link" href="https://en.wikipedia.org/wiki/Compare-and-swap"  target="_blank" rel="noopener"
    >compare-and-swap</a>、<a class="link" href="https://en.wikipedia.org/wiki/Fetch-and-add"  target="_blank" rel="noopener"
    >fetch-and-add</a>。所谓<a class="link" href="https://en.wikipedia.org/wiki/Linearizability#Primitive_atomic_instructions"  target="_blank" rel="noopener"
    >原子指令</a>，即处理器执行该指令不可分割且不可中断，换言之，原子操作要么完全发生，要么根本不发生。对于多处理器的计算机系统，为了保证原子性，甚至可能通过锁定总线，暂时禁止其它 CPU 与内存通信。</p>
<h3 id="synchronized">synchronized</h3>
<p>以前文的计数器为例，新增一个用 <code>synchronized</code> 修饰的 incrementSyncMethod 方法到 Counter，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">long</span> <span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">count</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">incrementSyncMethod</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">count</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">value</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用与测试 increment 方法相同的测试数据，测试启动相同个数的子线程重复调用同一个 Counter 对象的 incrementSyncMethod 方法相同次数，测试代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Test</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testIncrementSyncMethod</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Counter</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Counter</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">startThreads</span><span class="o">(</span><span class="n">counter</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">times</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">counter</span><span class="o">.</span><span class="na">incrementSyncMethod</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;threadName: %s, counterValue: %s\n&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">counter</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">excepted</span><span class="o">,</span> <span class="n">counter</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>测试结果如下图所示：</p>
<p><img src="/img/thread_concurrent/testIncrementSyncMethod.png"
	
	
	
	loading="lazy"
	
		alt="testIncrementSyncMethod"
	
	
></p>
<p>测试通过，期望值（exceptedCounterValue）与实际值（exceptedCounterValue）相等，其中一个子线程（Thread-1）与临时测试线程（Time-limited test）读取的 count 值相等。</p>
<p>防止线程干扰和内存一致性错误的机制是<strong>同步（Synchronization）</strong>。关键字 <code>synchronized</code>，翻译为已同步。当只有一个线程调用一个同步方法，它会隐式获得该方法的对象的内置锁（intrinsic lock）或监视器锁（monitor lock），并在该方法返回时隐式释放该对象的内置锁（即使返回是由未捕获异常引起的）。如果是用 <code>synchronized</code> 修饰的静态方法，这个线程会获得该静态方法所属的类所关联的 Class 对象的内置锁，因此，通过不同于该类的任何实例的锁来控制对该类的静态字段的访问。</p>
<p>这足以解释上面的两个线程读写同一个变量重复百万次，最后结果仍然正确的原因。两个线程调用同一个同步方法，一个线程快于另一个线程获得了这个方法的对象的内置锁，较慢的线程则被迫等待或被阻塞，已拥有该对象的内置锁的线程执行该方法的语句，修改共享实例字段，该方法返回时隐式释放了该对象的内置锁，另一个线程有机会拥有该对象的内置锁&hellip;&hellip;即使重复多次，一个时刻只能有一个线程正在访问共享实例字段，另一个线程被迫等待或被阻塞，也就是说这个两个线程对于共享实例字段的访问是<strong>互斥</strong>的，也就不会出现线程干扰和内存一致性错误。</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">线程 1</th>
<th style="text-align:center">线程 2</th>
<th style="text-align:center"> </th>
<th style="text-align:center">整数值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"> </td>
<td style="text-align:center"> </td>
<td style="text-align:center"> </td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">获得锁（成功）</td>
<td style="text-align:center"> </td>
<td style="text-align:center"> </td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td style="text-align:center">获得锁（失败）</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">读取</td>
<td style="text-align:center"> </td>
<td style="text-align:center">&lt;-</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">增加</td>
<td style="text-align:center"> </td>
<td style="text-align:center"> </td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">写回</td>
<td style="text-align:center"> </td>
<td style="text-align:center">-&gt;</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">释放锁</td>
<td style="text-align:center"> </td>
<td style="text-align:center"> </td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td style="text-align:center">获得锁（成功）</td>
<td style="text-align:center"> </td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td style="text-align:center">读取</td>
<td style="text-align:center">&lt;-</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td style="text-align:center">增加</td>
<td style="text-align:center"> </td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td style="text-align:center">写回</td>
<td style="text-align:center">-&gt;</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td style="text-align:center">释放锁</td>
<td style="text-align:center"> </td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table></div>
<p>编写同步代码的另一个方式是使用同步语句（Synchronized Statements），比如，改写一下测试方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Test</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testIncrementSyncBlock</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Counter</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Counter</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">startThreads</span><span class="o">(</span><span class="n">counter</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">times</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">counter</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">counter</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;threadName: %s, counterValue: %s\n&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">counter</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">excepted</span><span class="o">,</span> <span class="n">counter</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>或者添加一个 incrementSyncStmt 方法到 Counter 类，以及新增对应的测试用例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">long</span> <span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">count</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">incrementSyncMethod</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">count</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">incrementSyncStmt</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">count</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">value</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Test</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testIncrementSyncStmt</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Counter</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Counter</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">startThreads</span><span class="o">(</span><span class="n">counter</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">times</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">counter</span><span class="o">.</span><span class="na">incrementSyncStmt</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;threadName: %s, counterValue: %s\n&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">counter</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">excepted</span><span class="o">,</span> <span class="n">counter</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>采用同步语句需要显式指定一个提供内置锁的对象，同步语句建立临界区，多线程互斥访问该对象的状态（实例字段或静态字段）。</p>
<h4 id="膨胀">膨胀</h4>
<p>每一个 Java 对象都有一个与之关联的内置锁或监视器锁，其内部实体简称为监视器（monitor），又称为管程。因为有关键字 <code>synchronized</code>，所以每个 Java 对象都是一个潜在的监视器。一个线程可以锁定或解锁监视器，并且在任何时候只能有一个线程拥有该监视器。只有获得了监视器的所有权后，线程才可以进入受监视器保护的临界区。这与上文对内置锁的讨论一致，获得锁和释放锁可对应于 JVM 指令集的 <code>monitorenter</code> 和 <code>monitorexit</code>，即线程进入监视器和退出监视器。</p>
<p>如果对 Counter.class 进行反汇编：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">javap -v target/classes/io/h2cone/concurrent/Counter.class
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么可以看到同步方法和同步语句的可视化字节码。</p>
<p><img src="/img/thread_concurrent/monitor*.png"
	
	
	
	loading="lazy"
	
		alt="monitor*"
	
	
></p>
<p>同步方法虽然使用一个名为 <code>ACC_SYNCHRONIZED</code> 的 flag，但从 Java 虚拟机规范可以知道，底层行为也应该是进入监视器和退出监视器。</p>
<p>在 Java Hostspot VM 中，每一个 Java 对象的内存布局都有一个通用的<strong>对象头（object header）～</strong>结构。对象头的第一个字是 mark word，第二字是 klass pointer。</p>
<p><img src="/img/thread_concurrent/ObjectHeader.png"
	
	
	
	loading="lazy"
	
		alt="ObjectHeader"
	
	
></p>
<ol>
<li>
<p>mark word。通常存储同步状态（synchronization state）和对象的 hash code。在 GC 期间，可能包含 GC 状态。</p>
</li>
<li>
<p>klass pointer。指向另一个对象（元对象），该对象描述了原始对象的布局和行为。</p>
</li>
<li>
<p>普通对象头一般有 2 个字（word），数组对象头一般有 3 个字（word）。</p>
</li>
</ol>
<p>锁的信息被编码在在对象头的 mark word，Mark word 最低两位的值（Tag）包含了对象的同步状态：</p>
<p><img src="/img/thread_concurrent/MarkWord.png"
	
	
	
	loading="lazy"
	
		alt="MarkWord"
	
	
></p>
<ul>
<li>未锁定/已解锁（Unlocked）。没有线程拥有该对象的锁。</li>
<li>轻量级已锁定（Light-weight locked）。某个线程拥有该对象的轻量级锁。</li>
<li>重量级已锁定（Heavy-weight locked）。某个线程拥有该对象的重量级锁。</li>
<li>有偏向/可偏向（Biased / Biasable）。该对象已偏向或可偏向于某线程。</li>
</ul>
<p>下图描述了对象同步状态的转换，也是锁状态的转换。</p>
<p><img src="/img/thread_concurrent/Synchronization.gif"
	
	
	
	loading="lazy"
	
		alt="Synchronization"
	
	
></p>
<p>如果一个类的“可偏向”被禁用，该类的实例或对象的同步状态始于未锁定，即右手边。</p>
<ul>
<li>
<p>当一个线程调用该对象的同步方法或执行了指定该对象的同步语句，Mark word 副本和指向对象的指针存储在该线程当前栈帧（frame）内的锁记录（lock record）中。</p>
</li>
<li>
<p>JVM 尝试通过 <a class="link" href="https://en.wikipedia.org/wiki/Compare-and-swap"  target="_blank" rel="noopener"
    >compare-and-swap</a>（CAS）在该对象的 mark word 中安装一个指向锁记录的指针（pointer to lock record）。</p>
<ul>
<li>
<p>如果 CAS 操作成功，则该线程拥有了该对象的锁。该对象的 mark word 最后两位的值是 00。该锁称为<strong>轻量级锁</strong>。</p>
<ul>
<li>如果是递归或嵌套调用作用于该对象的同步代码，锁记录初始化为 0，而不是该对象的 mark word。</li>
</ul>
</li>
<li>
<p>如果 CAS 操作失败，则说明该对象已被其它线程锁定成功。JVM 首先检测该对象的 mark word 是否指向当前线程的栈。</p>
</li>
</ul>
</li>
<li>
<p>当多个线程并发锁定同一个对象，且竞争足够激烈时，轻量级锁升为<strong>重量级锁</strong>。重量级锁就是监视器，监视器管理等待的线程。等待获得监视器的线程状态就是“线程状态”所说的阻塞。</p>
</li>
</ul>
<p><img src="/img/thread_concurrent/fig20-1.gif"
	
	
	
	loading="lazy"
	
		alt="JavaMonitor"
	
	
></p>
<ul>
<li>
<p>JVM 使用的监视器类型可能如上图所示，该监视器由三个房间组成。中间只有一个线程，即监视器所有者。在左侧，一个小房间包含了入口集（entry set）。在右侧，另一个小房间包含了等待集合（wait set）。那么如果此 Java 监视器未过时，被阻塞的线程更可能处于入口集，因为等待集中的线程状态是“线程状态”所说的等待。</p>
</li>
<li>
<p>轻量级锁比重量级锁便宜很多，因为避免了操作系统互斥锁/条件变量（mutex / condition variables）与每个对象的联动。</p>
</li>
<li>
<p>如果有多个线程并发锁定共享对象，获得轻量级锁失败的线程通常不会被阻塞或被迫等待，而是<strong>自旋</strong>若干次，尝试获得锁。HotSpot VM 使用高级自适应自旋技术（advanced adaptive spinning techniques）来提高程序吞吐量，即使是锁定共享对象竞争激烈的程序。</p>
</li>
</ul>
<p>如果一个类的“可偏向”已启用，该类的实例或对象的同步状态始于未锁定，且无偏向，即左手边。</p>
<ul>
<li>
<p>据说，获得轻量锁的 CAS 在多处理器计算机系统上可能引起较大延迟，也许大多数对象在其生命周期中最多只能被一个线程锁定。早在 Java 6，此问题试图通过<strong>偏向锁</strong>优化。</p>
</li>
<li>
<p>该对象被第一个线程锁定时，只执行一次 CAS 操作，以将该线程 ID 记录到该对象的 mark word 中。于是该对象偏向于该线程。将来该线程对该对象的锁定和解锁无需任何原子操作或 mark word 的更新，甚至该线程栈中的锁记录也不会初始化。</p>
</li>
<li>
<p>当一个线程锁定已偏向于另一个线程的对象，该对象的偏向会被撤销（此操作必须暂停所有线程）。一般由偏向锁转为轻量级锁。</p>
</li>
<li>
<p>偏向锁的设计对一个线程重新获得锁更便宜和另一个线程获得锁更昂贵做了权衡：</p>
<ul>
<li>
<p>如果某个类的实例在过去频繁发生便偏向撤销，则该类将禁用“可偏向”。这个机制叫做批量撤销（bulk revocation）。</p>
</li>
<li>
<p>如果一个类的实例被不同的线程锁定和解锁，且不是并发，则该类的实例被重置为已解锁且无偏向，但仍是可偏向的对象，因为该类的“可偏向”不会被禁用。这个机制叫做批量重置偏向（bulk rebiasing）。</p>
</li>
</ul>
</li>
<li>
<p>当然可以从一开始就禁用偏向锁，启动 HotSpot VM 时指定关闭 <code>UseBiasedLocking</code>：</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-XX:-UseBiasedLocking
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于一些程序，偏向锁弊大于利，例如 <a class="link" href="https://github.com/apache/cassandra"  target="_blank" rel="noopener"
    >Cassandra</a> 就禁用了它。</p>
<p>简而言之，从 Java 6 开始就对 <code>synchronized</code> 做了不少优化，随着多线程锁定共享对象的竞争强度增大，锁的状态一般由偏向锁升为轻量级锁，竞争足够激烈时，则升为重量级锁，这个过程称为膨胀（inflate）。</p>
<h4 id="消除">消除</h4>
<p>在某些情况下，JVM 可以应用其它优化。例如，<a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html"  target="_blank" rel="noopener"
    >StringBuffer</a>，它有很多同步方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuffer</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;bar&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上所示，语句在某方法体内，因为 sb 是本地变量，所以调用 <code>append</code> 方法可以省略锁，这叫做锁消除（lock elision）。</p>
<h4 id="粗化">粗化</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;bar&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>再如上所示，如果 sb 是全局变量，且第一次 <code>append</code> 方法调用时已被某线程锁定成功，该线程可以避免 3 次锁定/解锁操作，而只需 1 次，这叫做锁粗化（lock coarsening）。</p>
<h3 id="死锁">死锁</h3>
<p>死锁描述了线程等待获得自己或对方已拥有的锁的僵持状态。</p>
<p><img src="/img/thread_concurrent/%e6%ad%bb%e9%94%81.png"
	
	
	
	loading="lazy"
	
		alt="死锁"
	
	
></p>
<p>防止死锁的有效方案如下：</p>
<ul>
<li>设置线程尝试获得锁的超时时间。</li>
<li>每个线程尝试获得多个资源的锁的顺序必须一致。</li>
</ul>
<p>比如上图，线程 1 和线程 2 都需要获得资源 1 和资源 2 的锁，只要每个线程尝试获得资源的锁的顺序是 (1，2)，也就不会是僵局。</p>
<h3 id="惯用锁">惯用锁</h3>
<p>除了 <code>synchronized</code>，JDK 提供的 <code>java.util.concurrent</code> 包，富有参差多态的锁。</p>
<h4 id="reentrantlock">ReentrantLock</h4>
<p><code>ReentrantLock</code>，可译为重入锁。重入（reentrant）是指一个线程可以再次拥有它已拥有且未释放的锁。通过上文“偏向锁和轻量级锁以及重量级锁”，可以知道内置锁是可重入锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Foobar</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;do something&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">doOtherThings</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">doOtherThings</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;do other things&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上代码所示，当一个线程用  Foobar 对象调用 doSomething 方法，成功获得该对象的内置锁后，继续调用 doOther 方法时，假设内置锁不是重入锁，那么因为 doSomething 方法还未返回，所以该对象的内置锁还未自动释放，那么该线程将被迫无限期等待。</p>
<p>或者断言该线程调用以下方法不会引起 <code>java.lang.StackOverflowError</code> 异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Foobar</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">doSomething</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>事实证明，以上断言都是错的。<code>ReentrantLock</code> 的一般用法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>相比于 <code>synchronized</code>，<code>Lock</code> 要求显式锁定（lock）和解锁（unlock），因此要特别注意即使发生异常也要释放锁。如果不希望线程获得锁失败后等待机会而是继续前行或者需要返回结果，可以使用以下的方法：</p>
<ul>
<li>
<p>boolean tryLock();</p>
</li>
<li>
<p>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</p>
</li>
</ul>
<p>一个典型的用法可能是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">if</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">tryLock</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// manipulate protected state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// perform alternative actions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="readwritelock">ReadWriteLock</h4>
<p><code>ReadWriteLock</code>，“读读共享，读写（写读）互斥，写写互斥”。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">ReadWriteLock</span> <span class="n">readWriteLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantReadWriteLock</span><span class="o">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Lock</span> <span class="n">readLock</span> <span class="o">=</span> <span class="n">readWriteLock</span><span class="o">.</span><span class="na">readLock</span><span class="o">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Lock</span> <span class="n">writeLock</span> <span class="o">=</span> <span class="n">readWriteLock</span><span class="o">.</span><span class="na">writeLock</span><span class="o">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>readLock 和 writeLock 类似于共享锁和排他锁。</p>
<h4 id="semaphore">Semaphore</h4>
<p><code>Semaphore</code>，翻译为信号量，也可实现锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">Semaphore</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Semaphore</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">semaphore</span><span class="o">.</span><span class="na">acquire</span><span class="o">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">semaphore</span><span class="o">.</span><span class="na">release</span><span class="o">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上所示，在同一时刻，最多只能有 3 个线程获得锁成功。</p>
<h4 id="分类目录">分类目录</h4>
<p>下面这张图来自美团技术团队，描述了 Java 主流锁的分类目录：</p>
<p><img src="/img/thread_concurrent/Java%e9%94%81%e5%88%86%e7%b1%bb.webp"
	
	
	
	loading="lazy"
	
		alt="Java锁分类"
	
	
></p>
<p>多线程竞争锁时，抢不到锁的线程，可能被迫等待（等待通知），或被阻塞（等待获得锁），抑或自旋。</p>
<h3 id="协调">协调</h3>
<h4 id="countdownlatch">CountDownLatch</h4>
<p><code>CountDownLatch</code>，一个安全的且只能递减的计数器，支持一个线程等待多个线程完成任务后恢复执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">CountDownLatch</span> <span class="n">latch</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CountDownLatch</span><span class="o">(</span><span class="n">2</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下降：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">latch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>等待：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">latch</span><span class="o">.</span><span class="na">await</span><span class="o">(</span><span class="n">3000</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上所示，主线程调用 <code>await</code> 方法被迫等待，除非设置了超时时间，否则直到最后一个子线程完成任务后调用 <code>countDown</code> 方法把 <code>latch</code> 的次数减少为 0 时，才能继续前行。</p>
<h4 id="cyclicbarrier">CyclicBarrier</h4>
<p><code>CyclicBarrier</code>，调用 <code>await</code> 方法的线程被迫等待，直到给定数量的线程都到达“栅栏”，同时起跑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">CyclicBarrier</span> <span class="n">barrier</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CyclicBarrier</span><span class="o">(</span><span class="n">8</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>等待：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">barrier</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="aqs">AQS</h3>
<p>它们最亲近的父类是 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html"  target="_blank" rel="noopener"
    >AbstractQueuedSynchronizer</a>。</p>
<p><img src="/img/thread_concurrent/SubClassOfAbstractQueuedSynchronizer.png"
	
	
	
	loading="lazy"
	
		alt="SubClassOfAbstractQueuedSynchronizer"
	
	
></p>
<h3 id="原子">原子</h3>
<p>保证多线程并发访问共享变量的程序正确，有另一个解决方案——原子操作。</p>
<h4 id="原子访问">原子访问</h4>
<p>在 Java 中，对以下变量的读取或写入都属于原子访问（atomic access）：</p>
<ul>
<li>
<p>引用类型的变量和大部分原始类型的变量（除了 <code>long</code> 和 <code>double</code> 的所有类型）。</p>
</li>
<li>
<p>声明为 <code>volatile</code> 的所有变量（包括 <code>long</code> 和 <code>double</code> 变量）。</p>
</li>
</ul>
<p>原子访问是指不可分且不可中断的操作，原子访问要么完全发生，要么根本不发生。虽然单一原子访问避免了线程干扰，但是不代表一组原子访问可以防止内存一致性错误。</p>
<p>使用 <code>volatile</code> 可降低内存一致性错误的风险，因为任何对 <code>volatile</code> 变量的写入都会与该变量的后续读取建立先发生在前的关系（happens-before relationship）。换言之，对 <code>volatile</code> 变量的更改始终对其它线程可见，即线程读取的 <code>volatile</code> 变量总是最新的。从 <a class="link" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.5"  target="_blank" rel="noopener"
    >The Java Virtual Machine Specification, Java SE 8 Edition # 4.5. Fields</a> 可以发现，<code>ACC_VOLATILE</code> 这个 flag 解释为 <code>volatile</code> 变量无法缓存，只要 JVM 遵循了这个规范项，则线程只会从主存中读取而不是从其它高速缓存。<code>volatile</code> 另一个作用是避免<strong>指令重排</strong>导致线程对变量的修改不可见，因为现在的 HotSpot VM 默认开启了 JIT 编译器（Just-in-time compiler），在运行时 JIT 可能应用指令重排优化。</p>
<p>回想前文所讨论的“非线程安全”中的计数器（Counter），非同步的“当前值加一”分解出来的三个步骤是原子访问，但是试验证明，出现了相互覆盖或丢失修改。由上一段可知，即使使用 <code>volatile</code> 修饰 Counter 的 count 字段，非同步的“当前值加一”仍然会出现内存一致性错误。</p>
<p>到此为止，难道只能使用 <code>synchronized</code> 或 Java 锁防止线程干扰和内存一致性错误？然而并不是，还有一种 <code>volatile</code> 变量组合 CAS 循环的方案，其实前面”惯用锁“中所说的 <code>ReentrantLock</code> 的实现也使用了 CAS。</p>
<h4 id="cas">CAS</h4>
<p>在“锁”中第一次提到了 compare-and-swap 这个指令，而在“偏向锁和轻量级锁以及重量级锁”中也提到了 CAS。CAS 的实现通常需要硬件层的支持，甚至可能在硬件层见到类似于软件层的锁概念。</p>
<p>现在用全新的 AtomicCounter 来代替那个混杂的 Counter。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AtomicCounter</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">AtomicLong</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicLong</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="n">current</span><span class="o">,</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">current</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">next</span> <span class="o">=</span> <span class="n">current</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="n">next</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">value</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>使用 <code>AtomicLong</code> 代替 <code>long</code>，它维护了一个用 <code>volatile</code> 修饰的 <code>long</code> 字段。</p>
</li>
<li>
<p>使用核心是 CAS 的方法（CAS 循环）代替使用 <code>synchronized</code> 的方法。</p>
</li>
</ul>
<p>其中新的 increment 方法的循环体内的前两个步骤和在 “非线程安全” 所分解的前两个步骤是一致的，第三个步骤是关键：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">count</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="n">next</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当有多个线程并发调用 increment 方法，到了第三个步骤，某一个线程比较 count 绑定的字段与它前一次读取的 current 变量是否相等，如果相等，则把 count 绑定的字段的值设为 next 的值，increment 方法返回，如果不相等，则表明 count 绑定的字段已被其它线程修改，<code>compareAndSet</code> 方法返回 <code>false</code>，跳到第一步，继续尝试。竞争足够激烈时，相比于 <code>synchronized</code>，<code>volatile</code> 变量组合 CAS 循环是非阻塞方案。</p>
<p><code>compareAndSet</code> 方法看似可分为两个步骤，实际上在底层，它是一个不可分且不可中断的原子指令，即从比较开始到赋值结束有且只有一个线程在执行此任务。该方法之所以可能返回 <code>false</code>，则是因为有可能一个线程赋值结束，与此同时，另一个线程开始比较。</p>
<p>同样，也给 AtomicCounter 写测试类，这一次线程加一，次数加一百万。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AtomicCounterTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">wait</span> <span class="o">=</span> <span class="n">3000</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">threads</span> <span class="o">=</span> <span class="n">3</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">times</span> <span class="o">=</span> <span class="n">2000000</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">excepted</span> <span class="o">=</span> <span class="n">threads</span> <span class="o">*</span> <span class="n">times</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testIncrement</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">AtomicCounter</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicCounter</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">startThreads</span><span class="o">(</span><span class="n">counter</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">times</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">counter</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;threadName: %s, counterValue: %s\n&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">counter</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="o">});</span>
</span></span><span class="line"><span class="cl">        <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">excepted</span><span class="o">,</span> <span class="n">counter</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">startThreads</span><span class="o">(</span><span class="n">AtomicCounter</span> <span class="n">counter</span><span class="o">,</span> <span class="n">Runnable</span> <span class="n">runnable</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">runnable</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">AtomicCounterTest</span><span class="o">.</span><span class="na">wait</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;threadName: %s, exceptedCounterValue: %s, actualCounterValue: %s\n&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">excepted</span><span class="o">,</span> <span class="n">counter</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>结果果然正确：</p>
<p><img src="/img/thread_concurrent/testIncrement-1.png"
	
	
	
	loading="lazy"
	
		alt="testIncrement-1"
	
	
></p>
<p>事实上，JDK 已经提供了许多操作原子类型实例的原子方法，上文最新版的“当前值加一”方法过于啰嗦，实际开发中请直接使用原子类的 <code>incrementAndGet</code> 方法。翻阅源码可以知道，原子类的 <code>compareAndSet</code> 方法使用了 <code>sun.misc.Unsafe</code> 的 <code>compareAndSwap</code> 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">boolean</span> <span class="nf">compareAndSwapObject</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var2</span><span class="o">,</span> <span class="n">Object</span> <span class="n">var4</span><span class="o">,</span> <span class="n">Object</span> <span class="n">var5</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">boolean</span> <span class="nf">compareAndSwapInt</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">var4</span><span class="o">,</span> <span class="kt">int</span> <span class="n">var5</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">boolean</span> <span class="nf">compareAndSwapLong</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var2</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var4</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var6</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意其中的 <code>native</code>，也就是说，下层的 <code>compareAndSwap</code> 函数由 C/C++ 实现，而 Java 程序可通过 <a class="link" href="https://en.wikipedia.org/wiki/Java_Native_Interface"  target="_blank" rel="noopener"
    >JNI</a> 调用这个函数。
虽然 JDK 没有包含 <code>sun.misc.Unsafe</code> 的源文件，但是通过对 <code>Unsafe.class</code>反编译，可以确定 <code>incrementAndGet</code> 方法同样使用了 CAS 函数，并且也使用 CAS 循环。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="nf">incrementAndGet</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getAndAddLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">1L</span><span class="o">)</span> <span class="o">+</span> <span class="n">1L</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>查看具体实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="nf">getAndAddLong</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var2</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var4</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">var6</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">var6</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getLongVolatile</span><span class="o">(</span><span class="n">var1</span><span class="o">,</span> <span class="n">var2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">while</span><span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="n">var1</span><span class="o">,</span> <span class="n">var2</span><span class="o">,</span> <span class="n">var6</span><span class="o">,</span> <span class="n">var6</span> <span class="o">+</span> <span class="n">var4</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">var6</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意，上文讨论的计数器在高并发场景中不一定是最优的方案，请看 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAdder.html"  target="_blank" rel="noopener"
    >LongAdder</a> 和 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAccumulator.html"  target="_blank" rel="noopener"
    >LongAccumulator</a>。</p>
<h4 id="原子类">原子类</h4>
<p>这个 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html"  target="_blank" rel="noopener"
    >java.util.concurrent.atomic</a> 包定义了支持对单个变量进行原子操作的类。</p>
<p>值得注意的是，<code>AtomicReference*</code> 用于防止多线程并发操作引用类型实例出现线程干扰和内存一致性错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Item</span> <span class="n">item</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="n">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">oldFirst</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="n">first</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">first</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">oldFirst</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上所示，一个简略的链表（LinkedList），维护了一个首结点（first），push 方法用于在链表表头插入结点，当多线程并发调用同一个 LinkedList 实例的 push 方法时，它们存储了各自的老首结点（Node<!-- raw HTML omitted --> oldFirst = first;），它们新建了各自的新首结点（new Node&lt;&gt;();），然后把 first 指向各自的结点（first = new Node&lt;&gt;();），因为 first 是它们的共享变量，所以可能已经出现相互覆盖或丢失更新，更不用说后面了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Item</span> <span class="n">item</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="n">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">oldFirst</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">newFirst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="n">newFirst</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">newFirst</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">oldFirst</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">first</span> <span class="o">=</span> <span class="n">newFirst</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>再如上所示，为了使问题清晰，只在 push 方法最后一步才设置 first。同样也因为 first 是它们的共享变量，所以它们都执行完最后一步后，可能出现一个或多个线程的新首结点游离于链表之外，因此，改用 CAS 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AtomicLinkedList</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicReference</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Item</span> <span class="n">item</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="n">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">newFirst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="n">newFirst</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">oldFirst</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">oldFirst</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">newFirst</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">oldFirst</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">oldFirst</span><span class="o">,</span> <span class="n">newFirst</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果还实现了删除结点的方法，则要小心 <a class="link" href="https://en.wikipedia.org/wiki/ABA_problem"  target="_blank" rel="noopener"
    >ABA 问题</a>，这时可考虑使用 <code>AtomicStampedReference</code>。</p>
<h3 id="collections">Collections</h3>
<h4 id="blockingqueue">BlockingQueue</h4>
<p>线程级的<strong>生产者-消费者</strong>问题的实质是分为生产者和消费者的两组线程共享同一个队列，消费者暂不能从队列拉取元素，除非队列非空，生产者暂不能推送元素到队列，除非队列非满。<a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html"  target="_blank" rel="noopener"
    >BlockingQueue</a> 既有基于数组的实现，也有基于链表的实现，可用来解决生产者-消费者问题（比如 <a class="link" href="https://github.com/h2cone/java-examples/blob/master/concurrent/src/main/java/io/h2cone/concurrent/BlockingQueueDemo.java"  target="_blank" rel="noopener"
    >BlockingQueueDemo</a>），当阻塞队列为空时，线程从阻塞队列拉取元素时会被阻塞或被迫等待，当阻塞队列已满时，线程推送元素到阻塞队列会被阻塞或被迫等待。</p>
<p><a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingDeque.html"  target="_blank" rel="noopener"
    >LinkedBlockingDeque</a> 和 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ArrayBlockingQueue.html"  target="_blank" rel="noopener"
    >ArrayBlockingQueue</a> 均使用了 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html"  target="_blank" rel="noopener"
    >Condition</a>，维护了队列非满条件变量和队列非空条件变量，如下图所示，通知的实现基于上文 &ldquo;通知&rdquo; 中提到的 park/unpark。</p>
<p><img src="/img/thread_concurrent/%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85.png"
	
	
	
	loading="lazy"
	
		alt="生产者-消费者"
	
	
></p>
<p>本质上，Condition 实例与 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html"  target="_blank" rel="noopener"
    >Lock</a> 实例绑定，通过 Lock 实例的 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html#newCondition"  target="_blank" rel="noopener"
    >newCondition</a> 方法可新建 Condition 实例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">BoundedBuffer</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">Condition</span> <span class="n">notFull</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">Condition</span> <span class="n">notEmpty</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">items</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">100</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">putptr</span><span class="o">,</span> <span class="n">takeptr</span><span class="o">,</span> <span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">Object</span> <span class="n">x</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">items</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">notFull</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">items</span><span class="o">[</span><span class="n">putptr</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(++</span><span class="n">putptr</span> <span class="o">==</span> <span class="n">items</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="n">putptr</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">notEmpty</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">take</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">notEmpty</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">Object</span> <span class="n">x</span> <span class="o">=</span> <span class="n">items</span><span class="o">[</span><span class="n">takeptr</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(++</span><span class="n">takeptr</span> <span class="o">==</span> <span class="n">items</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="n">takeptr</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">--</span><span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">notFull</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="concurrentmap">ConcurrentMap</h4>
<p><a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html"  target="_blank" rel="noopener"
    >ConcurrentMap</a> 是 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html"  target="_blank" rel="noopener"
    >Map</a> 的子接口，它定义了有用的原子操作，例如，仅在键存在时才删除或替换键值对，或仅在键不存在时才添加键值对，其中一个标准实现是 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html"  target="_blank" rel="noopener"
    >ConcurrentHashMap</a>，它是 <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html"  target="_blank" rel="noopener"
    >HashMap</a> 的线程安全版本。</p>
<p>JDK 7 的 <code>HashMap</code> 是基于拉链法的散列表。</p>
<p><img src="/img/algs4/separate-chaining.png"
	
	
	
	loading="lazy"
	
		alt="separate-chaining"
	
	
></p>
<p>如上面这张来自 <a class="link" href="https://algs4.cs.princeton.edu/34hash/"  target="_blank" rel="noopener"
    >algs4</a> 的图所示，散列表是一种符号表（symbol table），符号表是一种存储键值对的数据结构，支持两种操作：</p>
<ul>
<li>
<p>插入（put）。查找给定的键是否命中，若命中，则更新对应的值，若未命中，则插入键值对。</p>
</li>
<li>
<p>查找（get）。通过给定的键得到相应的值。</p>
</li>
</ul>
<p>基于拉链法的散列表维护了元素类型是链表的数组，它的查找算法可分为两步：</p>
<ol>
<li>
<p>使用 Hash 函数将给定的键转化为数组的索引。</p>
</li>
<li>
<p>在链表中查找给定的键，返回对应的值。</p>
</li>
</ol>
<p>如下面这张来自 <a class="link" href="https://deepakvadgama.com/blog/java-hashmap-internals/"  target="_blank" rel="noopener"
    >Java HashMap internals</a> 的图所示，在 <code>HashMap</code> 中，数组元素称为 bucket 或 bin，链表结点称为 entry。</p>
<p><img src="/img/data-structure/hashmap.jpg"
	
	
	
	loading="lazy"
	
		alt="hashmap"
	
	
></p>
<p>JDK 8 在 <code>HashMap</code> 中引入红黑树以优化查找算法。当一个桶的大小（链表大小）大于等于树化阈值（TREEIFY_THRESHOLD）且桶的数量（数组长度）大于等于 64，该桶将转化为一颗红黑树，当一个桶的大小小于等于解树阈值（TREEIFY_THRESHOLD），该桶将转化为链表。说到红黑二叉查找树，不得不先说二叉查找树和 2-3 查找树，未来将开启 <code>HashMap</code> 的新篇章。</p>
<p>翻阅源码可以知道，例如 <code>ConcurrentHashMap#put</code> 方法，<code>ConcurrentHashMap</code> 使用 CAS 和 <code>synchronized</code> 防止多线程并发访问它维护的链表或红黑树时出现线程干扰和内存一致性错误。</p>
<h3 id="一成不变">一成不变</h3>
<p>如果一个共享对象的状态只读，就不存在线程干扰和内存一致性错误，而且只要尝试改写状态时，每次都新建不同状态的这种对象并返回，完美制造了状态可变的假象（想象一下手翻书），也就不存在线程安全问题。这种对象，被称为不可变对象（Immutable Objects）。定义不可变对象的策略，可参考 <a class="link" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/imstrat.html"  target="_blank" rel="noopener"
    >A Strategy for Defining Immutable Objects</a>。</p>
<p>《The Joy of Clojure, second-edition》，1.4. Why Clojure isn’t especially object-oriented，作者对不可变的和可变的做了很棒的类比。</p>
<p><img src="/img/thread_concurrent/01fig07.jpg"
	
	
	
	loading="lazy"
	
		alt="01fig07"
	
	
>  <img src="/img/thread_concurrent/01fig08.jpg"
	
	
	
	loading="lazy"
	
		alt="01fig08"
	
	
></p>
<h2 id="后记">后记</h2>
<p>单机可以运行数百万个 Go 协程（Goroutine），却只能运行数千个 Java 线程。现在的 Java HotSpot VM，默认一个 Java 线程占有 1 M 的栈（以前是 256K），而且是大小固定的栈，而 Go 协程的栈是大小可变的栈，即随着存储的数据量变化而变化，并且初始值仅为 4 KB。确实，运行过多的 Java 线程容易导致 <a class="link" href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html#CIHHJDJE"  target="_blank" rel="noopener"
    >out of memory</a>，而且 Java 线程与内核线程（原生线程）是 1:1 映射，那么过多线程的上下文切换也会引起应用程序较大延迟；Go 协程与内核线程（原生线程）是多对一映射，Go 实现了自己的协程调度器，实际上要运行数百万个协程，Go 需要做得事情要复杂得多。</p>
<p>若只讨论 Java 单体应用承受高并发的场景，即使扩大线程池也不能显著提高性能或适得其反，相反，少量的线程就能处理更多的连接，比如，<a class="link" href="https://netty.io/"  target="_blank" rel="noopener"
    >Netty</a>。如果仍然认为重量级的 Java 线程是瓶颈，并且还想使用 Java 的话，不妨尝试 <a class="link" href="http://docs.paralleluniverse.co/quasar/"  target="_blank" rel="noopener"
    >Quasar</a>，它是一个提供<a class="link" href="https://en.wikipedia.org/wiki/Fiber_%28computer_science%29"  target="_blank" rel="noopener"
    >纤程</a>和类似于 Go 的 <a class="link" href="https://en.wikipedia.org/wiki/Channel_%28programming%29"  target="_blank" rel="noopener"
    >Channel</a> 以及类似于 Erlang 的 <a class="link" href="https://en.wikipedia.org/wiki/Actor_model"  target="_blank" rel="noopener"
    >Actor</a> 的 Java 库。</p>
<p>虽然进程之间不一定共享本机资源，但是线程之间的同步可以推广到进程之间的同步，比如，分布式锁。分布式系统中，代码一致的多个进程可能共享同一个数据库，数据库支持并发控制，比如，共享锁和排他锁以及 <a class="link" href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control"  target="_blank" rel="noopener"
    >MVCC</a>。</p>
<h2 id="文中代码">文中代码</h2>
<p>部分代码已发布，可查看 <a class="link" href="https://github.com/h2cone/java-examples/tree/master/concurrent"  target="_blank" rel="noopener"
    >concurrent</a>。</p>
<blockquote>
<p>本文首发于 <a class="link" href="https://h2cone.github.io"  target="_blank" rel="noopener"
    >https://h2cone.github.io</a></p>
</blockquote>
<h2 id="吸收更多">吸收更多</h2>
<ul>
<li>
<p><a class="link" href="https://book.douban.com/subject/26912767"  target="_blank" rel="noopener"
    >深入理解计算机系统（原书第3版）</a></p>
</li>
<li>
<p><a class="link" href="https://en.wikipedia.org/wiki/Thread_%28computing%29"  target="_blank" rel="noopener"
    >Thread (computing)</a></p>
</li>
<li>
<p><a class="link" href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html"  target="_blank" rel="noopener"
    >~jbell/CourseNotes/OperatingSystems/4_Threads</a></p>
</li>
<li>
<p><a class="link" href="http://www.it.uu.se/education/course/homepage/os/vt18/module-4/implementing-threads/"  target="_blank" rel="noopener"
    >Implementing threads :: Operating systems 2018</a></p>
</li>
<li>
<p><a class="link" href="https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html#Thread%20Management%7coutline"  target="_blank" rel="noopener"
    >HotSpot Runtime Overview # Thread Management</a></p>
</li>
<li>
<p><a class="link" href="https://www.zhihu.com/question/23096638"  target="_blank" rel="noopener"
    >JVM中的线程模型是用户级的么？</a></p>
</li>
<li>
<p><a class="link" href="https://medium.com/@unmeshvjoshi/how-java-thread-maps-to-os-thread-e280a9fb2e06"  target="_blank" rel="noopener"
    >How Java thread maps to OS thread</a></p>
</li>
<li>
<p><a class="link" href="https://jakubstransky.com/2017/12/19/hotspot-jvm-internal-threads/"  target="_blank" rel="noopener"
    >HotSpot JVM internal threads</a></p>
</li>
<li>
<p><a class="link" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html"  target="_blank" rel="noopener"
    >Java Tutorials # Concurrency # Guarded Blocks</a></p>
</li>
<li>
<p><a class="link" href="https://en.wikipedia.org/wiki/Thread_pool"  target="_blank" rel="noopener"
    >Thread pool</a></p>
</li>
<li>
<p><a class="link" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html"  target="_blank" rel="noopener"
    >Java Tutorials # Concurrency # Thread Pools</a></p>
</li>
<li>
<p><a class="link" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html"  target="_blank" rel="noopener"
    >Java Tutorials # Concurrency # Fork/Join</a></p>
</li>
<li>
<p><a class="link" href="https://en.wikipedia.org/wiki/Fork%E2%80%93join_model"  target="_blank" rel="noopener"
    >Fork–join model</a></p>
</li>
<li>
<p><a class="link" href="https://www.baeldung.com/java-completablefuture"  target="_blank" rel="noopener"
    >Guide To CompletableFuture</a></p>
</li>
<li>
<p><a class="link" href="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html"  target="_blank" rel="noopener"
    >Java Tutorials # Collections # Streams # Parallelism</a></p>
</li>
<li>
<p><a class="link" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html"  target="_blank" rel="noopener"
    >Java Tutorials # Concurrency # Synchronization</a></p>
</li>
<li>
<p><a class="link" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html"  target="_blank" rel="noopener"
    >The Java Language Specification, Java SE 8 Edition # Chapter 17. Threads and Locks</a></p>
</li>
<li>
<p><a class="link" href="https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html#Synchronization%7coutline"  target="_blank" rel="noopener"
    >HotSpot Runtime Overview # Synchronization</a></p>
</li>
<li>
<p><a class="link" href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization"  target="_blank" rel="noopener"
    >OpenJDK Wiki # HotSpot # Synchronization and Object Locking</a></p>
</li>
<li>
<p><a class="link" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10"  target="_blank" rel="noopener"
    >The Java Virtual Machine Specification, Java SE 8 Edition # 2.11.10. Synchronization</a></p>
</li>
<li>
<p><a class="link" href="https://www.cs.princeton.edu/picasso/mats/HotspotOverview.pdf"  target="_blank" rel="noopener"
    >The Hotspot Java Virtual Machine by Paul Hohensee</a></p>
</li>
<li>
<p><a class="link" href="https://blog.csdn.net/chenssy/article/details/54883355"  target="_blank" rel="noopener"
    >【死磕Java并发】&mdash;&ndash;深入分析synchronized的实现原理</a></p>
</li>
<li>
<p><a class="link" href="http://jpbempel.blogspot.com/2013/03/lock-lock-lock-enter.html"  target="_blank" rel="noopener"
    >Lock Lock Lock: Enter!</a></p>
</li>
<li>
<p><a class="link" href="https://www.artima.com/insidejvm/ed2/threadsynch.html"  target="_blank" rel="noopener"
    >Inside the Java Virtual Machine by Bill Venners # Thread Synchronization</a></p>
</li>
<li>
<p><a class="link" href="https://blogs.oracle.com/dave/biased-locking-in-hotspot"  target="_blank" rel="noopener"
    >Biased Locking in HotSpot</a></p>
</li>
<li>
<p><a class="link" href="https://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html"  target="_blank" rel="noopener"
    >HotSpotGlossary</a></p>
</li>
<li>
<p><a class="link" href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29"  target="_blank" rel="noopener"
    >Lock (computer science)</a></p>
</li>
<li>
<p><a class="link" href="https://en.wikipedia.org/wiki/Mutual_exclusion#Hardware_solutions"  target="_blank" rel="noopener"
    >Mutual exclusion</a></p>
</li>
<li>
<p><a class="link" href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29"  target="_blank" rel="noopener"
    >Synchronization (computer science)</a></p>
</li>
<li>
<p><a class="link" href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29"  target="_blank" rel="noopener"
    >Monitor (synchronization)</a></p>
</li>
<li>
<p><a class="link" href="https://www.javaspring.net/java/jvm-works-architecture"  target="_blank" rel="noopener"
    >Understand the object internally</a></p>
</li>
<li>
<p><a class="link" href="http://ibat.xyz/2017/03/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F--%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81%E7%9C%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97/"  target="_blank" rel="noopener"
    >单例模式&ndash;双重检验锁真的线程安全吗</a></p>
</li>
<li>
<p><a class="link" href="http://psy-lob-saw.blogspot.com/2013/05/know-thy-java-object-memory-layout.html"  target="_blank" rel="noopener"
    >Know Thy Java Object Memory Layout</a></p>
</li>
<li>
<p><a class="link" href="https://mp.weixin.qq.com/s/E2fOUHOabm10k_EVugX08g"  target="_blank" rel="noopener"
    >【基本功】不可不说的Java“锁”事</a></p>
</li>
<li>
<p><a class="link" href="https://book.douban.com/subject/30231515"  target="_blank" rel="noopener"
    >码农翻身：用故事给技术加点料</a></p>
</li>
<li>
<p><a class="link" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html"  target="_blank" rel="noopener"
    >Java Tutorials # Concurrency # Atomic Access</a></p>
</li>
<li>
<p><a class="link" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/atomicvars.html"  target="_blank" rel="noopener"
    >Java Tutorials # Concurrency # Atomic Variables</a></p>
</li>
<li>
<p><a class="link" href="https://www.infoq.cn/article/atomic-operation"  target="_blank" rel="noopener"
    >聊聊并发（五）——原子操作的实现原理</a></p>
</li>
<li>
<p><a class="link" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html"  target="_blank" rel="noopener"
    >Java Tutorials # Concurrency</a></p>
</li>
<li>
<p><a class="link" href="https://vipshop.github.io/vjtools/#/standard/chapter09"  target="_blank" rel="noopener"
    >唯品会 Java 开发手册 (九) 并发处理</a></p>
</li>
<li>
<p><a class="link" href="https://rcoh.me/posts/why-you-can-have-a-million-go-routines-but-only-1000-java-threads/"  target="_blank" rel="noopener"
    >Why you can have millions of Goroutines but only thousands of Java Threads</a></p>
</li>
<li>
<p><a class="link" href="https://colobu.com/2016/07/14/Java-Fiber-Quasar/"  target="_blank" rel="noopener"
    >Java中的纤程库 - Quasar</a></p>
</li>
<li>
<p><a class="link" href="https://colobu.com/2016/08/01/talk-about-quasar-again/"  target="_blank" rel="noopener"
    >继续了解Java的纤程库 - Quasar</a></p>
</li>
<li>
<p><a class="link" href="https://www.brianstorti.com/the-actor-model/"  target="_blank" rel="noopener"
    >The actor model in 10 minutes - Brian Storti</a></p>
</li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/java/">java</a>
        
            <a href="/tags/concurrent/">concurrent</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2022 Huangh&#39;s blog
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.11.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">Table of contents</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#进程与线程">进程与线程</a></li>
    <li><a href="#并发与并行">并发与并行</a></li>
    <li><a href="#java-多线程">Java 多线程</a>
      <ol>
        <li><a href="#java-进程">Java 进程</a></li>
        <li><a href="#启动线程">启动线程</a></li>
        <li><a href="#threadlocal">ThreadLocal</a></li>
        <li><a href="#线程状态">线程状态</a></li>
        <li><a href="#通知">通知</a>
          <ol>
            <li><a href="#waitnotify">wait/notify</a></li>
            <li><a href="#interrupt">interrupt</a></li>
            <li><a href="#parkunpark">park/unpark</a></li>
            <li><a href="#spurious-wakeup">spurious wakeup</a></li>
          </ol>
        </li>
        <li><a href="#线程池">线程池</a></li>
        <li><a href="#forkjoin">Fork/Join</a></li>
        <li><a href="#非线程安全">非线程安全</a></li>
      </ol>
    </li>
    <li><a href="#java-并发编程">Java 并发编程</a>
      <ol>
        <li><a href="#锁">锁</a></li>
        <li><a href="#synchronized">synchronized</a>
          <ol>
            <li><a href="#膨胀">膨胀</a></li>
            <li><a href="#消除">消除</a></li>
            <li><a href="#粗化">粗化</a></li>
          </ol>
        </li>
        <li><a href="#死锁">死锁</a></li>
        <li><a href="#惯用锁">惯用锁</a>
          <ol>
            <li><a href="#reentrantlock">ReentrantLock</a></li>
            <li><a href="#readwritelock">ReadWriteLock</a></li>
            <li><a href="#semaphore">Semaphore</a></li>
            <li><a href="#分类目录">分类目录</a></li>
          </ol>
        </li>
        <li><a href="#协调">协调</a>
          <ol>
            <li><a href="#countdownlatch">CountDownLatch</a></li>
            <li><a href="#cyclicbarrier">CyclicBarrier</a></li>
          </ol>
        </li>
        <li><a href="#aqs">AQS</a></li>
        <li><a href="#原子">原子</a>
          <ol>
            <li><a href="#原子访问">原子访问</a></li>
            <li><a href="#cas">CAS</a></li>
            <li><a href="#原子类">原子类</a></li>
          </ol>
        </li>
        <li><a href="#collections">Collections</a>
          <ol>
            <li><a href="#blockingqueue">BlockingQueue</a></li>
            <li><a href="#concurrentmap">ConcurrentMap</a></li>
          </ol>
        </li>
        <li><a href="#一成不变">一成不变</a></li>
      </ol>
    </li>
    <li><a href="#后记">后记</a></li>
    <li><a href="#文中代码">文中代码</a></li>
    <li><a href="#吸收更多">吸收更多</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
