<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>concurrency on Huangh&#39;s blog</title>
        <link>https://h2cone.github.io/tags/concurrency/</link>
        <description>Recent content in concurrency on Huangh&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Tue, 26 Sep 2023 22:32:39 +0800</lastBuildDate><atom:link href="https://h2cone.github.io/tags/concurrency/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>虚拟线程速览</title>
        <link>https://h2cone.github.io/2023/09/26/a-quick-look-at-virtual-threads/</link>
        <pubDate>Tue, 26 Sep 2023 22:32:39 +0800</pubDate>
        
        <guid>https://h2cone.github.io/2023/09/26/a-quick-look-at-virtual-threads/</guid>
        <description>&lt;h2 id=&#34;为了解决什么问题&#34;&gt;为了解决什么问题？&lt;/h2&gt;
&lt;p&gt;围绕 I/O 为核心的单机任务，难点之一是权衡应对负载增加的能力和开发的难易程度，从 &lt;a class=&#34;link&#34; href=&#34;https://h2cone.github.io/2020/03/08/network_nio/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;网络·NIO&lt;/a&gt; 中我们可以看到，Blocking I/O 优点是概念简单，缺点是在 I/O 操作完成之前，线程将无法执行任何其他操作，另外一点容易忽视的是它经过 Java 堆复制数据；Java NIO 劣势是概念较复杂（考虑异步容易出错），优势是支持非阻塞 I/O 和分配直接内存。一般情况下，基于 NIO 的服务比基于 BIO 的服务性能表现更好，但阻塞式 I/O 对广大开发者的心智负担更低。&lt;/p&gt;
&lt;p&gt;使用非阻塞 I/O 模型难以避免引入异步编程或响应式编程，而这些范式对于开发者来说是一种挑战，因此许多主流语言都提供了将单线程阻塞式代码转化为异步、非阻塞式代码的语法糖，比如 C#/JavaScript 的 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Async/await&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;async/await&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://h2cone.github.io/img/async-await-state-machine/navigation-trace-async-program.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;navigation-trace-async-program&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让出（yield）控制权给调用者线程。&lt;/li&gt;
&lt;li&gt;尝试隐藏异步调用与同步调用的差异，使其看起来像同步代码那样简单。&lt;/li&gt;
&lt;li&gt;是通过编译器自动将 async 方法转换为状态机来实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详情参考 &lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Task asynchronous programming model&lt;/a&gt;，随着越来越多的异步“传染”程序代码，性能提高代价可能是越来越难以推理代码。由于各种各样的原因，Java 官方没走 async/await 的道路，而是选择了类似于 Go/Kotlin &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Coroutine&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;协程&lt;/a&gt; 的“绿色线程”。所谓“绿色”是相对于 OS 线程而言，其中 Java 的线程瓶颈尤为严重，已知 1 线程需要大小 1MB 的栈，那么 10000 线程大约消费 10 GB 内存，这类来自 OS 的瓶颈促使开发人员考虑&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Thread_pool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;线程池&lt;/a&gt;技术。随着负载的增加，Java 线程池的扩展又是一大挑战，官方正式推出的挑战者是&lt;strong&gt;虚拟线程&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;每线程一请求的崛起&#34;&gt;“每线程一请求”的崛起？&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;ExecutorService&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;executor&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Executors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newThreadPerTaskExecutor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ofVirtual&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;my-thread&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;factory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ServerSocket&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serverSocket&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ServerSocket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;interrupted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;Socket&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serverSocket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;accept&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;executor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;submit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;handleRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IOException&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;finally&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;executor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在开始之前需要先澄清若干概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作系统线程（OS thread）。由操作系统管理的数据结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平台线程（Platform thread）。在 Java 19 之前，Thread 类的每个实例都是一个平台线程，是操作系统线程的包装器。创建一个平台线程就会创建一个操作系统线程，阻塞一个平台线程就会阻塞一个操作系统线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟线程（Virtual thread）。由 JVM 管理的轻量级线程。它们扩展了线程类，但不与特定的操作系统线程绑定。因此，虚拟线程的调度由 JVM 负责。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;载体线程（Carrier thread）。用于运行虚拟线程的平台线程称为载体线程。它不是一个有别于 Thread 或 VirtualThread 的类，而是一个功能名称。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JVM 级别的虚拟线程调度器对于虚拟线程应用 M : N 调度（M:N scheduling），M 表示较多虚拟线程数，N 表示较少平台线程数，并且 JVM 在可垃圾回收的堆中使用 Java 对象来表示虚拟线程的栈帧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://h2cone.github.io/img/thread_concurrent/jvts.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;jvts&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;调度器调度虚拟线程时给虚拟线程挂载（mount） 平台线程，执行某些代码时卸载（unmount）平台线程（通常发生在执行阻塞式 I/O 操作），将它释放到 &lt;a class=&#34;link&#34; href=&#34;https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ForkJoinPool&lt;/a&gt; 维护的线程池，虚拟线程会被阻塞在 I/O 操作直到完成时才被调度器重新调度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞或增加平台线程 ❌
&lt;ul&gt;
&lt;li&gt;某些方法（例如 Object.wait()）会触发捕获载体线程（capture the carrier thread），引起载体线程 ⬆️&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;阻塞或增加虚拟线程 ✅
&lt;ul&gt;
&lt;li&gt;固定虚拟线程（pinned thead）：不卸载直到在 native method 或 synchronized code 返回，期间载体线程⬇️&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虚拟线程 API 设计倾向于减轻开发人员心智负担，将虚拟线程复杂度转移到平台和库，但使用时仍然有不少注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;以“每线程一请求”方式编写简单的同步代码，&lt;strong&gt;采用阻塞式 I/O API&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将每个并发任务表示为一个虚拟线程，&lt;strong&gt;切勿池化虚拟线程&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;a class=&#34;link&#34; href=&#34;https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Semaphore.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Semaphore&lt;/a&gt; 限制并发数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要在 &lt;a class=&#34;link&#34; href=&#34;https://docs.oracle.com/en/java/javase/21/core/thread-local-variables.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ThreadLocal&lt;/a&gt; 中缓存昂贵的可重用对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免长时间或频繁固定虚拟线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;本文首发于 https://h2cone.github.io&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blogs.oracle.com/javamagazine/post/java-virtual-threads&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Exploring the design of Java’s new virtual threads&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://openjdk.org/jeps/444&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JEP 444: Virtual Threads&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Oracle # Virtual Threads&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://quarkus.io/blog/virtual-thread-1/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;When Quarkus meets Virtual Threads&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://quarkus.io/guides/virtual-threads&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Quarkus # VIRTUAL THREAD SUPPORT REFERENCE&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://spring.io/blog/2022/10/11/embracing-virtual-threads&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring # Embracing Virtual Threads&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://spring.io/blog/2023/09/20/hello-java-21&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hello, Java 21&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.diva-portal.org/smash/get/diva2:1763111/FULLTEXT01.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Comparing Java Virtual Threads with Spring Reactive Webflux&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
